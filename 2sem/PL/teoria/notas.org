#+TITLE: Notas

* REGEX
Aula 22 fevereiro

** Expressões regulares
+ a :: pesquisar a
+ a.b :: a seguido de b (ou seja, a qualquer coisa b)
+ a|b :: a ou b
+ () :: agrupar

  Exemplo:
  (0|..|9) -> número entre 0 e 9
+ a? :: opcional ter a
+ * :: 0 ou mais vezes o q vier antes
+ + :: 1 ou mais vezes o q vier antes
+ [] :: um dos caracteres dentro do array
  #+begin_src bash
  [ab] -> a ou b
  (a|b) -> igual ao de cima
  #+end_src
+ \d :: um único digito
+ \D :: um não digito
+ \w :: uma palavra
+ \s :: espaco em branco
+ . :: qualquer um caracter
+ \$ :: pesquisar carateres especiais

*** Bracket expressions
+ [abc] :: a ou b ou c
+ [a-c] :: igual a cima
+ [^a-zA-Z] :: string que nao contem uma letra de a para z ou A para Z

*** Greedy and Lazy match
The quantifiers **(*+{})** are greedy operators, so the expand the match as far as they can through the provided text.

+ <.+?> :: matches any character one or more times included inside **<** and **>**, expanding as needeed
+ <[^<>]+> :: better solution (avoid the usage of **.**)
*** Boundaries \b and \b
+ \babc\b :: matches only lines with abc
+ \babc\B :: matches only if the pattern is fully surrounded by word characters. In this case the word **abc** will not be select

*** Back-references \1
+ ([abc])\1 :: using **\1** it matches the same text **that was matched by the first capturing group**
+ ([abc])([de])\2\1 :: we can use **\2** (\3,\4,...) to identigy the same text that **was matched by the second (...) capturing group**
+ (?<foo>[abc]\k<foo>) :: we put the name **foo** to the group and we reference it later **(\k<foo>)**. The result is the same of the first regex

*** Look-ahead and Look-behind (?=) and (?<=)
+ d(?=r) :: matches a **d** only if is **followed** by **r**, but r will not be a part of the overall regex match

+ (?<=r)d :: matches a **d** only if is **preceded** by **r**, but r will not be a part of the overall regex match


We can use also the negation operator
    + d(?!r) :: matches a **d** only if is **not followed by r**
    + (?!<r)d :: matches a **d** only if is **not preceded by r**

** Flags
*** Grouping and capturing
+ a(bc) :: captura o grupo com o valor **bc**
+ a(?:bc)* :: using **?:** we disable the capturing group
+ a(?<foo>bc)* :: using **?<foo>** we put a name to the group

** Exercicios
+ Inteiros e binarios
  #+begin_src python
  Int = ('-'|'+')?('0'|..|'9')+
  binario = (0|1)*
  #+end_src

+ binário sem conter o 011
  #+begin_src python
  ^1*(01|0)*$

  ^1*|0*(10|1$)?
  #+end_src

+ named groups
  #+begin_src python
  palavra = r'(?P<pal>\b\w+\b)'

  m = re.search(palavra, linha)
  #+end_src

* Aula 8 Março
** Tokenizer
a = 34 + 23 -7*2

ID ATRIB INT OP INT OP INT

#+begin_SRC python
ID = r'[_a-zA-Z]\w*'
ATRIB = r'='
INT = r'\d+'
OP = r'\[\:*\-+\/]'
#+end_SRC

*** Cod

#+begin_SRC python
def tokenize(code):
    token_specification = [
        ('NUM', r'\d+'), # numeros
        ('ID', r'[_a-zA-Z]\w*'), # id
        ('ATRIB', r'='), # numeros
        ('OP', r'\[\:*\-+\/]'),
        ('NEWLINE', r'\n'), # newlines
        ('SKIP', r'[ \t]+'),
        ('ERRO', r'.*'),
    ]

    regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specification)

    reconhecidos = []

    mo = re.finditer(regex, code)
    for m in mo:
        # dic = m.groupdict()
        # print(dic)
       reconhecidos.append(m)

    return reconhecidos
#+end_SRC

** Máquina de estados
*** Inteiros
[[file:./photos/maquinaEstadosInt.png][maquina de estados inteiros]]

+ S :: Estado inicial
+ B :: Estado final
*** Alg

#+begin_SRC python
AFD = (S, Z, Estados, funçãoTransição)

    d    _     letra
    ------------------------
S  B  A  A
B  B  _  _
A  A  A  A
#+end_SRC

+ S :: Estado inicial
+ B :: Estado final

* Aula 09 Março
** Expressoes Regurales - Linguagens Regulares
Autómatos Finitos Deterministas
Gramáticas Regulares
 (T, N, S, P)

[]
[1]
[1,2,3]

Símbolos terminais:
1. Sinais :: são constituídos por um caráter;
2. Palavras reservadas ::  constantes (exemplos: while, if)
3. Terminais variáveis :: Exemplos: identificadores, inteiros, ...


#+begin_src python
T = {'[',']', inteiro, ','}
N = {S, Conteúdo, ContS, Conteúdo, Cont}
P = {
    S -> '[' Counteúdo ']'
    Conteúdo -> inteiro
            |   vazio
    Const -> vazio | ',' inteiro Const
}
#+end_src

* Aula 22 Março
** Gramaticas independentes de contexo (GIC)
+ Uma gramatica é um tuplo ~(T, N, S, P)~:
  - T :: é o conj. de simbolos terminais ou vocabulario da linguagem
  - N :: é o conj. de simbolos nao terminais ou estruturaes e que representam estruturas da linguagem
  - P :: é o conj. de regras de producao com o qual se podem derivar as frases da linguagem
  - S :: é o axioma, ou o simbolo nao terminal a partir do qual se deve comecar a derivar a frase
** Exemplo : a linguagem dos parantesis
Especifica uma gramatica que defina a linguagem dos parentesis :

#+begin_src python
T = {'(',')'}
N = {S}
S = S
P = {
    p1: S -> ()
    p2: S -> S S
    p3: S -> ( S )
}
#+end_src

Derivacao da frase: ~()(())~ :

#+begin_example
S = p2 => SS
  = p1 => ()S
  = p3 => ()(S)
  = p1=>()(())
#+end_example

Há varias formas...

#+begin_src python
T = {'(',')'}
N = {S}
S = S
P = {
    p1: S -> ( S ) S
    p2: S -> simbolo gregro
}
#+end_src

** Exercicio: descreve a linguagem gerada pela gramatica
#+begin_src python
T = {'0','1'}
N = {S}
S = S
P = {
    p1: S -> 0
    p2: S -> 0 S
    p3: S -> 1 S
}
#+end_src

** Exercicio expressoes aritmeticas (soma, sub, mult, div)

#+begin_src python
T = {'+','-', '*', '/', '(', ')', num}
N = {Exp}
S = Exp
P = {
    p1: Exp -> num
    p2: Exp -> ( Exp )
    p3: Exp -> Exp + Exp
    p4: Exp -> Exp - Exp
    p5: Exp -> Exp * Exp
    p6: Exp -> Exp / Exp
}
#+end_src

*** Exemplo (4+5)*(2-6)

Isto é feito a mão, não é a forma correta
#+begin_example
Exp = Exp * Exp
  => (Exp) * (Exp)
  => (Exp + Exp) * (Exp - Exp)
  => (num + num) * (num - num)
#+end_example

** Algoritmos de reconhecimento /analise /Parsing
*** Top Down
+ LL(1): dirigido por tabela
+ recursivo descendente (LL(1))
*** Bottom Up:
+ LR(0)
+ SLR(1)
+ LALR(0)
